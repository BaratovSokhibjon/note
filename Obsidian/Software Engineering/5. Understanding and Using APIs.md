### synchronous

-  first-come, first-served order
- enable the application to receive data immediately
- The application making the API request must wait for the response before performing any additional code execution tasks.
- 

### asynchronous
- request is an action that takes some time for the server to process
- request to server to start fetching data from some service
- an immediate response with data is not guaranteed.


### Common Architectural Styles
> RPC, SOAP, and REST.

- RPC: remote procedure call
	- often synchronous meaning client process waits (blocks) for the response from server process and then after getting the response it unblocks -> continues working
	- application (client) --> call --> application (server) - this one has the desired method
	- client doesn't know the call is happening remotely
	- client app just runs the function with arguments 
	- applicible to different transport protocols including below:
		- XML-RPC
		- JSON-RPC
		- NFS (Network File System)
		- Simple Object Access Protocol (SOAP)
- SOAP: 
	- messaging protocol
	- built by Microsoft
	- communication using xml in different platforms (mobile/desktop or mac/windows)
	- commonly used with HTTP
	- Main characteristics:
		- Independent
			- Different platforms can use
			- Stateless
			- Regardless of OS or programming language
		- Extensible
			- because of it's XML architecture, devs can use SOAP with their extra layers of security and reliability layers
		- Neutreal:
			- can be used over any protocol (almost)
	- Message example body:
		- Envelope: must be root element, namespace tells  XML doc is a SOAP message
		- Header: optional, if exists: first child of namespace, includes app-specific information like authorization info and others
		- Body: in its own namespace, transport data must be XML message
		- Fault: optional, if exists: first child of body, tells about errors
	- Message example:
	```
		<?xml version="1.0"?>
		
		<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
		
		    <soap:Header/>
		
		    <soap:Body>
		
		        <soap:Fault>
		
		            <faultcode>soap:Server</faultcode>
		
		            <faultstring>Query request too large.</faultstring>
		
		        </soap:Fault>
		
		    </soap:Body>
		
		</soap:Envelope>
	```

- REST: Representational state transfer
	- six elements of architecture:
		- Client-Server
		- Stateless
		- Cache
		- Uniform Interface
		- Layered System
		- Code-On-Demand
	- Header types
		- Request headers
			- Request headers include additional information that doesn't relate to the content of the message.
		- Entity headers
			- Entity headers are additional information that describe the content of the body of the message.
	- Body
		- if body exists, data type is defined in header as `content-type` key
		- **pagination** is used when the data is big and will be sent in chunks, it is mostly used via query parameters specifying how many records should be send per response
		- **compressed data**: 
			- the client application can specify the data to be compressed through the request itself by having the  `Content-Encoding` Field in the request header
			- possible encoding types:
				- gzip
				- compress
				- deflate
				- br
				- identity
				- *
			- if encoding type is not possible
				- server will return 406 -- Not acceptable status code
	- **Authentication**
		- Basic
			- Basic Auth transmits credentials as username/password pairs separated with a colon ( `:` ) and encoded using Base64.
			- Basic Auth information will be provided in the header:
				- `Authorization: Basic <username>:<password>`
			- Not secure if not redered in HTTPS
			- Encoded but not encrypted meaning easy to get credentials
		- Bearer
			- Bearer Authentication uses a bearer token, which is a string generated by an authentication server such as an Identity Service (IdS).
			- the Bearer Auth information will be provided in the header:
				- `Authorization: Bearer <bearer token>`
			- should be redered via HTTPS
- API Key
	- **Definition**: A unique API token string generated by an API server and assigned to a user after logging in with credentials.
	- **Purpose**: 
	  - All requests from the user include this string as an authentication token, making each request stateless.
	- **Security**: Should be used via HTTPS.

	- Methods to Provide API Key in RESTful APIs
		1. **Query String**
		   - **Description**: The API key is included as part of the URL query string.
		   - **Recommendation**: Only suitable for public API keys.
		   - **Example**: `https://api.example.com/resource?api_key=<API Key>`
		
		1. **Header**
		   - **Description**: The API key is passed in the request header.
		   - **Common Keys**:
		     - `Authorization: <API Key>`
		     - `Authorization: APIkey <API Key>`
		     - `APIkey: <API Key>`
		   - **Example**: 
		     ```
		     Authorization: APIkey abc123xyz
		     ```
		
		1. **Body Data**
		   - **Description**: The API key is included in the request body with a unique key identifier.
		   - **Content Type**: `application/json`
		   - **Example**:
		     ```json
		     {
		       "api_key": "<API Key>",
		       "data": "example"
		     }
		     ```
		
		1. **Cookie**
		   - **Description**: The API key is passed as a cookie with a unique key identifier.
		   - **Format**: `Cookie: API_KEY=<API Key>`
		   - **Example**:
		     ```
		     Cookie: API_KEY=abc123xyz
		     ```


- Authorization mechanism:
	- OAuth 1.0 or OAuth 2.0 (Open authentication)
	- Currently OAuth 2.0 is common and it is not backwards compatible
	- It let's third party applications to gain limited access to HTTP service by approval of owner
	- OAuth lets the user provide credentials directly to the authorization server, typically an Identity Provider (IdP) or an Identity Service (IdS)
	- This process of obtaining the token is called a flow.
	- Then that token is used as a Bearer Authentication


### Rate Limiting Algorithms
- **Leaky bucket**
	- The request comes in inconsistent rate but the server will process the requests at a constant rate, queuing the remaining requests. If request queue is full, the request is rejected
- **Token bucket**
	- API using the Token Bucket algorithm sets a rate limit of 10 requests per client per hour. If a client makes 11 requests within an hour, the 11th request will be rejected because there are no tokens left. On the other hand, if the client then makes no requests for 6 hours, it can then make 60 requests at once, because those tokens have accumulated.
- **Fixed window counter**
	-  It uses a counter rather than a collection of tokens.
	- The counter cannot be accumulated.
	- To go back to our previous example of 10 requests per hour using this algorithm, the 11th request in an hour will still be rejected, but after 6 hours with no requests, the client can still only make 10 requests in a single hour because those "unused" requests were not accumulated.
- **Sliding window counter**
	- the rate is five requests per minute, when the server receives a new request, it checks how many requests have been made in the last 60 seconds. If five requests have already been made, then the new request will be rejected.

- API's keep information about the rate limits in the response header and they can be:
	- **X-RateLimit-Limit:** The maximum number of requests that can be made in a specified unit of time
	- **X-RateLimit-Remaining:** The number of requests remaining that the requester can make in the current rate limit window
	- **X-RateLimit-Reset:** The time the rate limit window will reset


### Webhooks
>  Think of asking someone "tell me right away if X happens". That "someone" is the webhook provider, and you are the application.

A webhook is an HTTP callback, or an HTTP POST, to a specified URL that notifies your application when a particular activity or “event” has occurred in one of your resources on the platform.